<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Car Part Compositor & Inventory</title>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #1a1a1a;
            color: white;
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* --- GUI Layout --- */
        #toolbar {
            width: 120px;
            background: #2d2d2d;
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px 0;
            gap: 12px;
            z-index: 10;
        }

        #main-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            background: #111;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #inventory {
            width: 260px;
            background: #2d2d2d;
            border-left: 1px solid #444;
            display: flex;
            flex-direction: column;
            padding: 15px;
        }

        /* --- Canvas Styling --- */
        #canvas-container {
            position: relative;
            box-shadow: 0 0 30px rgba(0,0,0,0.7);
            /* Checkered background for transparency visualization */
            background-image: 
                linear-gradient(45deg, #222 25%, transparent 25%), 
                linear-gradient(-45deg, #222 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #222 75%), 
                linear-gradient(-45deg, transparent 75%, #222 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            border: 1px solid #333;
            border-radius: 8px;
        }

        canvas {
            display: block;
            cursor: crosshair;
            max-width: 100%;
            max-height: 85vh;
            border-radius: 8px;
        }

        /* --- Inventory & UI Elements --- */
        .inventory-item {
            width: 100%;
            height: auto;
            min-height: 80px;
            background: #3d3d3d;
            margin-bottom: 12px;
            border: 2px solid #444;
            cursor: pointer;
            object-fit: contain;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .inventory-item:hover {
            border-color: #007bff;
            transform: scale(1.02);
        }

        .inventory-item.selected-item {
            border-color: #007bff;
            box-shadow: 0 0 8px rgba(0, 123, 255, 0.5);
        }

        .btn {
            background: #444;
            color: white;
            border: none;
            padding: 10px 5px;
            border-radius: 4px;
            cursor: pointer;
            width: 90px;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            text-transform: uppercase;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: background 0.1s;
        }

        .btn:hover { background: #555; }
        .btn.active { background: #007bff; }

        #controls {
            position: absolute;
            top: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 30px;
            display: flex;
            align-items: center;
            gap: 15px;
            backdrop-filter: blur(5px);
            z-index: 5;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        #ai-status {
            margin-top: auto;
            padding: 12px;
            background: #004d40;
            border-radius: 6px;
            font-size: 12px;
            text-align: center;
            font-weight: 500;
        }

        input[type=range] {
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="toolbar">
        <button class="btn" onclick="document.getElementById('fileInput').click()">LOAD CAR</button>
        <input type="file" id="fileInput" hidden accept="image/*">
        <hr style="width: 70%; border: 0.5px solid #444; margin: 5px 0;">
        <button id="selectBtn" class="btn active" onclick="setMode('select')">CROP TOOL</button>
        <button id="placeBtn" class="btn" onclick="setMode('place')">PASTE TOOL</button>
        <hr style="width: 70%; border: 0.5px solid #444; margin: 5px 0;">
        <button id="undoBtn" class="btn" onclick="undo()">UNDO</button>
        <button id="redoBtn" class="btn" onclick="redo()">REDO</button>
        <button class="btn" onclick="resetCanvas()">RESET</button>
        <button class="btn" style="background: #28a745;" onclick="downloadPNG()">DOWNLOAD</button>
        <button class="btn" style="background: #c62828;" onclick="exportToAI()">PUSH TO AI</button>
    </div>

    <div id="main-area">
        <div id="controls">
            <label style="font-size: 12px;">Selection Sensitivity:</label>
            <input type="range" id="tolerance" min="1" max="150" value="40">
        </div>
        <div id="canvas-container">
            <canvas id="mainCanvas"></canvas>
        </div>
    </div>

    <div id="inventory">
        <h3 style="margin: 0 0 15px 0; font-size: 14px; letter-spacing: 1px;">PARTS LIBRARY</h3>
        <div id="inventory-list" style="overflow-y: auto; flex-grow: 1; padding-right: 5px;">
            <!-- Parts will be added here -->
        </div>
        
        <!-- NEW EDITING PANEL -->
        <div id="inventory-editor-panel" style="display: none; padding-top: 15px; border-top: 1px solid #444; margin-top: 15px;">
            <div id="selection-buttons" style="display: flex; gap: 10px; margin-bottom: 10px;">
                <button id="placeSelectedBtn" class="btn" style="flex-grow: 1; background: #007bff; width: auto;" onclick="startPlacement()">PLACE</button>
                <button id="editSelectedBtn" class="btn" style="flex-grow: 1; background: #555; width: auto;" onclick="showEditControls()">EDIT</button>
            </div>

            <div id="edit-controls" style="display: none; padding: 10px; border-radius: 6px; background: #3d3d3d;">
                <p style="font-size: 12px; margin-bottom: 5px; font-weight: bold; color: #ccc;">TRANSFORM:</p>
                
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                    <button id="flipBtn" class="btn" style="width: 50%; padding: 8px; font-size: 10px; background: #555;" onclick="toggleFlip()">FLIP HORIZONTAL</button>
                    <button id="colorBtn" class="btn" style="width: 50%; padding: 8px; font-size: 10px; background: #555;">COLOR (TBD)</button>
                </div>

                <label for="scaleRange" style="font-size: 11px; display: block; margin-bottom: 5px;">
                    Scale: <span id="scaleValue" style="font-weight: bold; color: #00bcd4;">1.00x</span>
                </label>
                <input type="range" id="scaleRange" min="0.01" max="3" step="0.01" value="1" style="width: 100%;">
                
                <button class="btn" style="width: 100%; margin-top: 15px; background: #28a745;" onclick="startPlacement()">APPLY & PLACE</button>
            </div>
        </div>

        <div id="ai-status">
            Ready for img2img
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const invList = document.getElementById('inventory-list');
        
        let mode = 'select'; 
        let baseImage = null;
        let selectedPartImg = null; // The IMG element that is ready to be placed
        let editingPart = null; // The DOM IMG element currently selected in inventory
        
        // NEW State Variables for editing
        let currentScale = 1.0;
        let isFlipped = false;
        
        // INTERACTION STATE VARIABLES
        let placedParts = []; // Array of CanvasPart instances
        let activePart = null; // The CanvasPart being manipulated
        let dragOffset = { x: 0, y: 0 }; // Offset for dragging
        let isRotating = false;
        let lastMousePos = { x: 0, y: 0 }; // Used for rotation calculation

        // HISTORY (undo/redo)
        const history = [];
        let historyIndex = -1; // points to current state in history
        const MAX_HISTORY = 50;

        function pushHistory() {
            // Serialize placedParts into descriptors
            const state = placedParts.map(p => ({
                src: p.image.src,
                x: p.x,
                y: p.y,
                scale: p.scale,
                rotation: p.rotation,
                isFlipped: p.isFlipped
            }));

            // If we are not at the end of history, truncate redo states
            if (historyIndex < history.length - 1) history.splice(historyIndex + 1);

            history.push(state);
            if (history.length > MAX_HISTORY) history.shift();
            historyIndex = history.length - 1;
            updateUndoRedoButtons();
        }

        function restoreState(state) {
            if (!state) {
                placedParts = [];
                return;
            }

            // Load all images then rebuild placedParts
            const loaders = state.map(desc => new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const part = new CanvasPart(img, desc.x, desc.y, desc.scale, desc.isFlipped);
                    part.rotation = desc.rotation || 0;
                    resolve(part);
                };
                img.src = desc.src;
            }));

            Promise.all(loaders).then(parts => {
                placedParts = parts;
            });
        }

        function undo() {
            if (historyIndex <= 0) return;
            historyIndex -= 1;
            restoreState(history[historyIndex]);
            updateUndoRedoButtons();
        }

        function redo() {
            if (historyIndex >= history.length - 1) return;
            historyIndex += 1;
            restoreState(history[historyIndex]);
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
            document.getElementById('undoBtn').style.opacity = historyIndex <= 0 ? 0.5 : 1;
            document.getElementById('redoBtn').style.opacity = historyIndex >= history.length - 1 ? 0.5 : 1;
        }

        // Default Size
        canvas.width = 1000;
        canvas.height = 600;

        /**
         * Class to manage placed car parts for dragging and rotation.
         */
        class CanvasPart {
            constructor(image, x, y, scale = 1.0, isFlipped = false) {
                this.image = image;
                this.scale = scale;
                this.isFlipped = isFlipped;
                
                // Calculate dimensions based on scale
                this.naturalWidth = image.naturalWidth;
                this.naturalHeight = image.naturalHeight;
                this.width = image.naturalWidth * scale;
                this.height = image.naturalHeight * scale;

                this.x = x;
                this.y = y;
                this.rotation = 0; // in radians
                this.isSelected = false;
            }

            draw(context) {
                context.save();
                
                const halfW = this.width / 2;
                const halfH = this.height / 2;
                
                // 1. Translate to center for rotation
                context.translate(this.x + halfW, this.y + halfH);
                
                // 2. Apply Rotation
                context.rotate(this.rotation);

                // 3. Apply Flip (Scaling by -1 on X)
                if (this.isFlipped) {
                    context.scale(-1, 1);
                }

                // 4. Draw image centered at the translated origin
                context.drawImage(this.image, -halfW, -halfH, this.width, this.height);
                
                // Restore transformations before drawing handles/outline
                context.restore(); 
                
                // Redraw selection/handle (must be done in a separate block relative to canvas space)
                if (this.isSelected) {
                    context.save();
                    // Re-apply translation and rotation for the selection box
                    context.translate(this.x + halfW, this.y + halfH);
                    context.rotate(this.rotation);
                    
                    // Draw Selection Box
                    context.strokeStyle = '#007bff';
                    context.lineWidth = 2;
                    context.strokeRect(-halfW, -halfH, this.width, this.height);
                    
                    // Rotation Handle (top center)
                    context.beginPath();
                    context.arc(0, -halfH - 15, 8, 0, 2 * Math.PI);
                    context.fillStyle = '#ff3b30'; // Red color
                    context.fill();
                    context.strokeStyle = 'white';
                    context.lineWidth = 1;
                    context.stroke();
                    context.restore();
                }
            }
            
            // Hit test for dragging (checks if point is within the bounding box)
            hitTest(mx, my) {
                const center_x = this.x + this.width / 2;
                const center_y = this.y + this.height / 2;
                
                const dx = mx - center_x;
                const dy = my - center_y;

                // Inverse rotation of the click point
                const cos = Math.cos(-this.rotation);
                const sin = Math.sin(-this.rotation);
                
                const local_x = dx * cos - dy * sin;
                const local_y = dx * sin + dy * cos;
                
                return (
                    local_x > -this.width / 2 && local_x < this.width / 2 &&
                    local_y > -this.height / 2 && local_y < this.height / 2
                );
            }
            
            // Hit test for the rotation handle
            hitTestRotateHandle(mx, my) {
                if (!this.isSelected) return false;
                
                const center_x = this.x + this.width / 2;
                const center_y = this.y + this.height / 2;
                
                // Rotation handle position relative to the center (before object rotation)
                const handle_offset_x = 0;
                const handle_offset_y = -this.height / 2 - 15;

                // Apply object's rotation to get global handle position
                const cos = Math.cos(this.rotation);
                const sin = Math.sin(this.rotation);
                
                const handle_x = center_x + (handle_offset_x * cos - handle_offset_y * sin);
                const handle_y = center_y + (handle_offset_x * sin + handle_offset_y * cos);

                // Check distance to click point (10px radius)
                const dist = Math.sqrt(
                    Math.pow(mx - handle_x, 2) + 
                    Math.pow(my - handle_y, 2)
                );
                
                return dist < 10; 
            }
        }


        // RENDER LOOP (Animates the canvas to show movement/rotation)
        function drawScene() {
            // 1. Clear Canvas (and restore base image)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (baseImage) {
                ctx.drawImage(baseImage, 0, 0, canvas.width, canvas.height);
            }
            
            // 2. Draw all placed parts
            placedParts.forEach(part => part.draw(ctx));
            
            requestAnimationFrame(drawScene);
        }

        // Start the main render loop immediately
        requestAnimationFrame(drawScene);


        // --- UI & Utility Functions ---

        document.getElementById('fileInput').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    baseImage = img;
                    resizeCanvasToImage(img);
                    pushHistory(); // record base state
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        };

        function resizeCanvasToImage(img) {
            // Constrain canvas to fit within the main area for responsiveness
            const maxWidth = window.innerWidth * 0.6;
            const maxHeight = window.innerHeight * 0.8;
            let width = img.width;
            let height = img.height;

            if (width > maxWidth) {
                height *= (maxWidth / width);
                width = maxWidth;
            }
            if (height > maxHeight) {
                width *= (maxHeight / height);
                height = maxHeight;
            }

            canvas.width = width;
            canvas.height = height;
            
            // Redraw immediately after resize
            drawScene(); 
        }

        function setMode(newMode) {
            mode = newMode;
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById(newMode + 'Btn');
            if(btn) btn.classList.add('active');
            
            // Deselect all parts when switching modes
            placedParts.forEach(p => p.isSelected = false);
            activePart = null;
        }

        function resetCanvas() {
            // Clear all placed parts
            placedParts = [];
            activePart = null;
            // Redraw base image
            if (baseImage) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(baseImage, 0, 0, canvas.width, canvas.height);
            }
            
            // Hide editor panel
            document.getElementById('inventory-editor-panel').style.display = 'none';

            pushHistory();
        }

        // --- INVENTORY EDITING LOGIC ---
        
        function selectInventoryItem(imgElement) {
            // 1. Reset selection styles on all items
            document.querySelectorAll('.inventory-item').forEach(i => i.classList.remove('selected-item'));
            imgElement.classList.add('selected-item');
            
            // 2. Update editing state
            editingPart = imgElement; // The actual image data source
            
            // 3. Reset transformation controls for the new item
            currentScale = 1.0;
            isFlipped = false;
            document.getElementById('scaleRange').value = 1.0;
            document.getElementById('scaleValue').innerText = '1.00x';
            document.getElementById('flipBtn').style.background = '#555'; 
            
            // 4. Show the selection buttons and hide edit controls
            document.getElementById('inventory-editor-panel').style.display = 'block';
            document.getElementById('selection-buttons').style.display = 'flex';
            document.getElementById('edit-controls').style.display = 'none';
            setMode('place'); // Set to place mode (but don't enable placement until the user hits PLACE or APPLY & PLACE)
        }

        function startPlacement() {
            if (!editingPart) return;
            
            // Set the image source and current transformation states for placement
            selectedPartImg = editingPart; 
            
            // Hide the editor panel controls but keep the mode set
            document.getElementById('inventory-editor-panel').style.display = 'none';
            
            setMode('place');
        }

        function showEditControls() {
            document.getElementById('selection-buttons').style.display = 'none';
            document.getElementById('edit-controls').style.display = 'block';
        }

        function toggleFlip() {
            isFlipped = !isFlipped;
            const btn = document.getElementById('flipBtn');
            btn.style.background = isFlipped ? '#28a745' : '#555';
        }

        // Add event listener for the resize slider
        document.getElementById('scaleRange').addEventListener('input', (e) => {
            currentScale = parseFloat(e.target.value);
            document.getElementById('scaleValue').innerText = currentScale.toFixed(2) + 'x';
        });

        // --- AUTO-CROP AND INVENTORY CREATION ---

        /**
         * AUTO-CROP: Non-AI Flood Fill Segmentation
         * Determines a contiguous area of similar color starting at (startX, startY)
         */
        function autoCrop(startX, startY) {
            if (!baseImage) { console.warn("Load a car image first!"); return; }

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const tolerance = parseInt(document.getElementById('tolerance').value);
            
            const startIdx = (startY * canvas.width + startX) * 4;
            // Check if the click is outside the image bounds or on a transparent area (alpha = 0)
            if (startIdx < 0 || startIdx >= data.length || data[startIdx + 3] === 0) return;

            const targetR = data[startIdx];
            const targetG = data[startIdx + 1];
            const targetB = data[startIdx + 2];

            const mask = new Uint8Array(canvas.width * canvas.height);
            const stack = [[startX, startY]];
            
            let minX = startX, maxX = startX, minY = startY, maxY = startY;

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const pos = y * canvas.width + x;

                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height || mask[pos]) continue;

                const idx = pos * 4;
                const r = data[idx];
                const g = data[idx+1];
                const b = data[idx+2];
                const a = data[idx+3];

                // Check alpha to prevent selecting background
                if (a < 128) continue; 
                
                // Euclidean distance for color similarity
                const diff = Math.sqrt(
                    Math.pow(r - targetR, 2) + 
                    Math.pow(g - targetG, 2) + 
                    Math.pow(b - targetB, 2)
                );

                if (diff <= tolerance) {
                    mask[pos] = 1;
                    if (x < minX) minX = x; if (x > maxX) maxX = x;
                    if (y < minY) minY = y; if (y > maxY) maxY = y;

                    // Push neighbors onto stack
                    stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
                }
            }

            extractAndInventory(mask, minX, minY, maxX, maxY);
        }

        function extractAndInventory(mask, minX, minY, maxX, maxY) {
            const w = maxX - minX + 1;
            const h = maxY - minY + 1;
            if (w < 5 || h < 5) return; // Ignore tiny selections

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = w;
            tempCanvas.height = h;
            const tCtx = tempCanvas.getContext('2d');
            
            // Get data from the region
            const originalData = ctx.getImageData(minX, minY, w, h);
            const partData = tCtx.createImageData(w, h);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const globalX = x + minX;
                    const globalY = y + minY;
                    const maskIdx = globalY * canvas.width + globalX;
                    const pixelIdx = (y * w + x) * 4;

                    if (mask[maskIdx]) {
                        // Copy pixel data if it belongs to the segmented area
                        partData.data[pixelIdx] = originalData.data[pixelIdx];
                        partData.data[pixelIdx+1] = originalData.data[pixelIdx+1];
                        partData.data[pixelIdx+2] = originalData.data[pixelIdx+2];
                        partData.data[pixelIdx+3] = 255; 
                    } else {
                        // Make the rest transparent
                        partData.data[pixelIdx+3] = 0; 
                    }
                }
            }
            tCtx.putImageData(partData, 0, 0);
            
            // Create Inventory UI Element (Image)
            const img = new Image();
            img.src = tempCanvas.toDataURL();
            img.className = 'inventory-item';
            img.onclick = function() {
                selectInventoryItem(this);
            };
            invList.prepend(img);
        }

        /**
         * INTERACTION HANDLERS (Canvas)
         */
        
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            // Get click coordinates relative to canvas resolution
            const mx = Math.floor((e.clientX - rect.left) * (canvas.width / rect.width));
            const my = Math.floor((e.clientY - rect.top) * (canvas.height / rect.height));
            lastMousePos = { x: mx, y: my }; 
            
            if (mode === 'select') {
                autoCrop(mx, my);
                return;
            } 
            
            // Manipulation/Placement Mode
            if (mode === 'place') {
                // Clear state for new interaction
                activePart = null;
                isRotating = false;
                
                // 1. Check for hits on existing parts (in reverse order to hit top-most part first)
                for (let i = placedParts.length - 1; i >= 0; i--) {
                    const part = placedParts[i];
                    part.isSelected = false; 

                    // Check rotation handle hit
                    if (part.hitTestRotateHandle(mx, my)) {
                        activePart = part;
                        activePart.isSelected = true;
                        isRotating = true;
                        // Bring to front
                        placedParts.splice(i, 1);
                        placedParts.push(activePart);
                        e.preventDefault();
                        return;
                    }
                    
                    // Check drag hit
                    if (part.hitTest(mx, my)) {
                        activePart = part;
                        activePart.isSelected = true;
                        
                        // Calculate offset from click to center (pre-rotation)
                        const center_x = part.x + part.width / 2;
                        const center_y = part.y + part.height / 2;
                        
                        const dx = mx - center_x;
                        const dy = my - center_y;
                        
                        // Inverse rotate the click point to get drag offset relative to part's local space
                        const cos = Math.cos(-part.rotation);
                        const sin = Math.sin(-part.rotation);
                        
                        dragOffset.x = dx * cos - dy * sin;
                        dragOffset.y = dx * sin + dy * cos;
                        
                        // Bring to front
                        placedParts.splice(i, 1);
                        placedParts.push(activePart);
                        e.preventDefault();
                        return;
                    }
                }
                
                // 2. If no hit, and an inventory part is ready to be placed, place it.
                if (selectedPartImg) {
                    const scaledWidth = selectedPartImg.naturalWidth * currentScale;
                    const scaledHeight = selectedPartImg.naturalHeight * currentScale;

                    const newPart = new CanvasPart(
                        selectedPartImg, 
                        mx - scaledWidth / 2, // Center part on cursor
                        my - scaledHeight / 2, // Center part on cursor
                        currentScale,
                        isFlipped
                    );
                    
                    placedParts.push(newPart);
                    activePart = newPart;
                    activePart.isSelected = true;

                    // Reset selectedPartImg and editor state after placement
                    selectedPartImg = null;
                    editingPart = null;
                    document.getElementById('inventory-editor-panel').style.display = 'none';
                    document.querySelectorAll('.inventory-item').forEach(i => i.classList.remove('selected-item'));

                    pushHistory(); // record placement
                } else {
                    // If we clicked outside and nothing was selected, deselect everything
                    placedParts.forEach(p => p.isSelected = false);
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = Math.floor((e.clientX - rect.left) * (canvas.width / rect.width));
            const my = Math.floor((e.clientY - rect.top) * (canvas.height / rect.height));

            if (!activePart) return;

            if (isRotating) {
                const center_x = activePart.x + activePart.width / 2;
                const center_y = activePart.y + activePart.height / 2;

                // Calculate angle from center to mouse position
                const angle1 = Math.atan2(lastMousePos.y - center_y, lastMousePos.x - center_x);
                const angle2 = Math.atan2(my - center_y, mx - center_x);
                
                activePart.rotation += (angle2 - angle1);
                lastMousePos = { x: mx, y: my };

            } else { // Dragging
                // Calculate new center based on current mouse position and stored offset
                const dx = mx - lastMousePos.x;
                const dy = my - lastMousePos.y;

                activePart.x += dx;
                activePart.y += dy;

                lastMousePos = { x: mx, y: my };
            }
        });

        // Ensure mouseup anywhere clears active interaction and records history
        window.addEventListener('mouseup', () => {
            if (activePart) {
                pushHistory();
            }
            activePart = null;
            isRotating = false;
        });

        canvas.addEventListener('mouseup', () => {
            // Stop active manipulation (handled by window)
        });

        /**
         * AI INTEGRATION PLACEHOLDER
         */
        async function exportToAI() {
            const status = document.getElementById('ai-status');
            status.innerText = "Generating Blob...";
            status.style.background = "#e65100";

            canvas.toBlob((blob) => {
                console.log("Image Data Ready for AI img2img API:", blob);
                
                setTimeout(() => {
                    status.innerText = "Sent to AI Engine";
                    status.style.background = "#0288d1";
                }, 800);
            }, 'image/png');
        }

        // Download final composition as PNG
        function downloadPNG() {
            // Create temp canvas to render full-quality composition
            const out = document.createElement('canvas');
            out.width = canvas.width;
            out.height = canvas.height;
            const octx = out.getContext('2d');

            if (baseImage) octx.drawImage(baseImage, 0, 0, out.width, out.height);

            // Draw parts in order
            placedParts.forEach(p => {
                octx.save();
                const halfW = p.width / 2;
                const halfH = p.height / 2;
                octx.translate(p.x + halfW, p.y + halfH);
                octx.rotate(p.rotation);
                if (p.isFlipped) octx.scale(-1, 1);
                octx.drawImage(p.image, -halfW, -halfH, p.width, p.height);
                octx.restore();
            });

            out.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'composition.png';
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
            }, 'image/png');
        }

        // Initialize empty history state
        pushHistory();
        updateUndoRedoButtons();
    </script>
</body>
</html>
